import type { SchemaData, AttributeData, FunctionData, ApiType } from "@grimo/metadata"
import CodeBuilder from "@grimo/code-builder"

export interface GenerateOptions {
  global?: boolean
}

export default function generate(schema: SchemaData, { global }: GenerateOptions): string {
  const now = new Date()
  /** Header */
  const hd = new CodeBuilder()
    .push(`// GENERATED BY @grimo/generate-typescript`)
    .line(` AT ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`)
    .line(`import { SchemaData, EnumData, TableData, TypeData, ViewData, FunctionData } from "grimo"`)
  
  const td = new CodeBuilder().line(`// Types`).line()
  const md = new CodeBuilder().line("// Metadata").line()

  if (global) td.line("declare global {").indent()

  defineApi(schema, td)
  defineMetadata(md)
  writeEnums(schema, td, md)
  writeComposites(schema, td, md)
  writeTables(schema, td, md)
  writeViews(schema, td, md)
  writeFunctions(schema, td, md)
  exportApi(schema, md)

  if (global) td.dedent().line("}")

  return [hd, td, md].join("\n")
}

function defineApi(schema: SchemaData, td: CodeBuilder) {
  td.line(`/** Database API. */`)
    .line(`export interface Api {`)
    .indent()
    .line(`tables: Tables`)
    .line(`views: Views`)
    .line(`functions: Functions`)
    .line(`schema: SchemaData`)
    .dedent()
    .line(`}`)
    .line()
    .line(`export interface Tables {`)
    .indent()
  for (const table of schema.tables) {
    td.line(`${table.name}: ${table.apiName}`)
  }
  td.dedent()
    .line(`}`)
    .line()
    .line(`export interface Views {`)
    .indent()
  for (const view of schema.views) {
    td.line(`${view.name}: ${view.apiName}`)
  }
  td.dedent()
    .line(`}`)
    .line()
    .line(`export interface Types {`)
    .indent()
  for (const type of schema.types) {
    td.line(`${type.name}: ${type.apiName}`)
  }
  td.dedent()
    .line(`}`)
    .line()
    .line(`export interface Functions {`)
    .indent()
  for (const func of schema.functions) {
    td.line(`${func.name}: ${func.signatureName}`)
  }
  td.dedent()
    .line(`}`)
    .line()
}

function defineMetadata(md: CodeBuilder) {
  md.line(`export const schema: SchemaData = {`)
    .indent()
    .line(`enums: [],`)
    .line(`types: [],`)
    .line(`tables: [],`)
    .line(`views: [],`)
    .line(`functions: [],`)
    .dedent()
    .line(`}`)
    .line()
}

function exportApi(schema: SchemaData, md: CodeBuilder) {
  md.line(`export const Api: Api = {`)
    .indent()
    .line(`schema,`)
    .line(`tables: undefined as unknown as Tables,`)
    .line(`views: undefined as unknown as Views,`)
    .line(`functions: undefined as unknown as Functions,`)
    .dedent()
    .line(`}`)
}

function writeEnums(schema: SchemaData, td: CodeBuilder, md: CodeBuilder) {
  td.line(`// Enum Types`).line()
  md.line(`// Enum Metadata`).line()
  for (const enu of schema.enums) {
    td.line(`/** \`${enu.name}\` enum.*/`)
      .line(`export type ${enu.apiName} =`)
    md.line(`export const ${enu.apiName}: EnumData = {`)
      .indent()
      .line(`name: "${enu.name}",`)
      .line(`apiName: "${enu.apiName}",`)
      .line(`fields: [`)
      .indent()
    for (const field of enu.fields) {
      td.line(`| "${field.name}"`)
      md.line(`{ name: "${field.name}", order: ${field.order} },`)
    }
    td.line()
    md.dedent()
      .line(`],`)
      .dedent()
      .line(`}`)
      .line(`schema.enums.push(${enu.apiName})`)
      .line()
  }
}

function writeComposites(schema: SchemaData, td: CodeBuilder, md: CodeBuilder) {
  td.line(`// Composite Types`).line()
  md.line(`// Composite Type Metadata`).line()
  for (const type of schema.types) {
    td.line(`/** \`${type.name}\` composite type. */`)
      .line(`export interface ${type.apiName} {`)
      .indent()
    md.line(`export const ${type.apiName}: TypeData = {`)
      .indent()
      .line(`name: "${type.name}",`)
      .line(`apiName: "${type.apiName}",`)
      .line(`attributes: [`)
      .indent()
    writeAttributes(type.attributes, td, md)
    td.dedent()
      .line(`}`)
      .line()
    md.dedent()
      .line(`],`)
      .dedent()
      .line(`}`)
      .line(`schema.types.push(${type.apiName})`)
      .line()
  }
}

function writeTables(schema: SchemaData, td: CodeBuilder, md: CodeBuilder) {
  td.line(`// Tables`).line()
  md.line(`// Table Metadata`).line()
  for (const table of schema.tables) {
    td.line(`/** \`${table.name}\` table. */`)
      .line(`export interface ${table.apiName} {`)
      .indent()
    md.line(`export const ${table.apiName}: TableData = {`)
      .indent()
      .line(`name: "${table.name}",`)
      .line(`apiName: "${table.apiName}",`)
      .line(`columns: [`)
      .indent()
    writeAttributes(table.columns, td, md)
    td.dedent()
      .line(`}`)
      .line()
    md.dedent()
      .line(`],`)
      .dedent()
      .line(`}`)
      .line(`schema.tables.push(${table.apiName})`)
      .line()
  }
}

function writeViews(schema: SchemaData, td: CodeBuilder, md: CodeBuilder) {
  td.line(`// Views`).line()
  md.line(`// View Metadata`).line()
  for (const view of schema.views) {
    td.line(`/** \`${view.name}\` view. */`)
      .line(`export interface ${view.apiName} {`)
      .indent()
    md.line(`export const ${view.apiName}: ViewData = {`)
      .indent()
      .line(`name: "${view.name}",`)
      .line(`apiName: "${view.apiName}",`)
      .line(`updatable: ${view.updatable},`)
      .line(`insertable: ${view.insertable},`)
      .line(`columns: [`)
      .indent()
    writeAttributes(view.columns, td, md)
    td.dedent()
      .line(`}`)
      .line()
    md.dedent()
      .line(`]`)
      .dedent()
      .line(`}`)
      .line(`schema.views.push(${view.apiName})`)
      .line()
  }
}

function writeFunctions(schema: SchemaData, td: CodeBuilder, md: CodeBuilder) {
  td.line(`// Functions`).line()
  md.line(`// Function Metadata`).line()
  for (const func of schema.functions) {
    const parameters = func.parameters.map(param => `${param.name}: ${tsType(param)}`).join(", ")
    td.line(`/** \`${func.name}\` function. */`)
      .line(`export type ${func.signatureName} = (${parameters}) => Promise<${tsType(func)}>`)
      .line()
    md.line(`export const ${func.signatureName}: FunctionData = {`)
      .indent()
      .line(`name: "${func.name}",`)
      .line(`signatureName: "${func.signatureName}",`)
      .line(`type: "${func.type}",`)
      .line(`apiType: ${JSON.stringify(func.apiType)},`)
      .line(`parameters: [`)
      .indent()
    writeAttributes(func.parameters, td, md, true)
    md.dedent()
      .line(`],`)
      .dedent()
      .line(`}`)
      .line(`schema.functions.push(${func.signatureName})`)
      .line()
  }
}

function writeAttributes(attributes: AttributeData[], td: CodeBuilder, md: CodeBuilder, skipType = false) {
  for (const attribute of attributes) {
    if (!skipType) {
      td.line(`${attribute.name}: ${tsType(attribute)}`)
    }
    md.line(`{ name: "${attribute.name}",`)
      .indent()
      .line(`type: "${attribute.type}",`)
      .line(`order: ${attribute.order},`)
      .line(`nullable: ${attribute.nullable ?? false},`)
      .line(`apiType: ${JSON.stringify(attribute.apiType)},`)
      .dedent()
      .line(`},`)
  }
}

function tsType({ apiType, nullable }: { apiType: ApiType, nullable?: boolean }) {
  let type = ""
  if (Array.isArray(apiType)) {
    if (apiType[0] === "array") {
      type = tsType({ apiType: apiType[1] }) + '[]'
    }
    else {
      type = apiType[1]
    }
  }
  else if (["bigint", "date"].includes(apiType)) {
    type = "string"
  }
  else if (apiType === "json") {
    type = "any"
  }
  else {
    type = apiType
  }
  if (nullable) {
    type += " | null"
  }
  return type
}
