import type { SchemaData, AttributeData, FuncData } from "@grimo/metadata"

/** Generated TypeScript definitions to represent database API. */
export default function generate(schema: SchemaData): string {
  const now = new Date()
  return ts`// GENERATED BY GRIMO
// AT ${now.toLocaleDateString()} ${now.toLocaleTimeString()}
import { SchemaData, EnumData, TableData, TypeData } from "grimo"

// Base
export const Schema: SchemaData = {
  enums: [],
  types: [],
  tables: [],
  functions: []
}

// Enums
${schema.enums.map(e => ts`
export enum ${e.apiName} {
  ${e.fields.sort(f => f.order).map(f => f.name).join(",\n  ")}
  
}
export const ${e.apiName}Type: EnumData = {
  name: "${e.name}",
  apiName: "${e.apiName}",
  fields: [${e.fields.sort(f => f.order).map(f => ts`
    { name: "${f.name}",
      order: ${f.order}
    },`).join("\n  ")}
  ],
};
Schema.enums.push(${e.apiName}Type);
`).join("\n")}
// Types
${schema.types.map(t => ts`
export interface ${t.apiName} {
  ${t.attributes.sort(a => a.order).map(a => ts`${a.name}: ${generateTsType(a.apiType as string[])};`)
      .join("\n  ")}
}
export const ${t.apiName}: TypeData = {
  name: "${t.name}",
  apiName: "${t.apiName}",
  attributes: [${t.attributes.sort(a => a.order).map(generateAttributeMetadata).join(",\n")}],
};
Schema.types.push(${t.apiName});
`).join("\n")}
// Tables
${schema.tables.map(t => ts`
export interface ${t.apiName} {
  ${t.columns.sort(a => a.order).map(a => ts`${a.name}: ${generateTsType(a.apiType as string[])};`)
          .join("\n  ")}
}
export const ${t.apiName}: TableData = {
  name: "${t.name}",
  apiName: "${t.apiName}",
  columns: [${t.columns.sort(a => a.order).map(generateAttributeMetadata).join(",\n")}],
};
Schema.tables.push(${t.apiName});
`).join("\n")}
// Functions
${schema.functions.map(f => ts`
export type ${f.name} = ${generateFunctionSignature(f)};
export const ${f.name}: FuncData = {
  name: "${f.name}",
  returnType: ${generateTsTypeMetadata(f.returnType as string[])},
  parameters: [${f.parameters.sort(p => p.order).map(generateAttributeMetadata).join(",\n")}]
}
Schema.functions.push(${f.name});
`).join("\n")}
export interface Tables {
${schema.tables.map(t =>
            `  ${t.name}: ${t.apiName}`).join(";\n")}
}

export interface Functions {
${schema.functions.map(f =>
              `  ${f.name}: ${generateFunctionSignature(f)}`).join(";\n")}
}

export interface Api {
  tables: Tables;
  functions: Functions;
  schema: SchemaData;
}

// This is to avoid a type parameter.
export const Api: Api = {
  tables: undefined as unknown as Tables,
  functions: undefined as unknown as Functions,
  schema: Schema
};

export default Api;
`;
}

function generateFunctionSignature(f: FuncData) {
  return "(" + f.parameters.map(p =>
    `${p.name}: ${generateTsType(p.apiType as string[])}`
  ).join(", ") + `) => Promise<${generateTsType(f.returnType as string[])}>`
}

function generateAttributeMetadata({ name, order, nullable, apiType }: AttributeData) {
  return ts`
    { name: "${name}",
      order: ${order},
      nullable: ${nullable},
      apiType: ${generateTsTypeMetadata(apiType as string[])}
    }`
}

function generateTsTypeMetadata(apiType: string[]): string {
  if (apiType[0] === "interface") {
    return `["interface", ${apiType[1]}]`
  }
  else if (apiType[0] === "enum") {
    return `["enum", ${apiType[1]}Type]`
  }
  else if (apiType[0] === "array") {
    return `["array", ${generateTsTypeMetadata(apiType[1] as unknown as string[])}]`
  }
  return `"${apiType}"` as unknown as string
}

function generateTsType(apiType: string[]): string {
  if (apiType[0] === "array") {
    return generateTsType(apiType[1] as unknown as string[]) + "[]"
  }
  if (Array.isArray(apiType)) {
    return apiType[1]
  }
  if (apiType === "json") {
    return "any"
  }
  return apiType as unknown as string
}

/** Pass-thru template strings for IDE syntax highlighting. */
function ts(literals: TemplateStringsArray, ...placeholders: (string | number | boolean)[]) {
  let s = ""
  for (let i = 0; i < placeholders.length; i++) {
    s += literals[i]
    s += placeholders[i]
  }
  s += literals[literals.length - 1]
  return s
}
